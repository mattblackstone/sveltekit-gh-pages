import{S as he,i as ce,s as ge,k as a,q as c,a as g,l as o,m as r,r as f,h as t,c as v,n as m,J as fe,b as ve,G as e,H as K}from"../chunks/index.a3f7c049.js";import{b as le}from"../chunks/paths.7c3e458d.js";function me(de){let n,E,u,b,L,D,k,s,A,N,O,p,d,y,z,C,G,V,W,w,h,x,J,M,T,P,j,I,B,F,S,i,Q;return{c(){n=a("main"),E=a("header"),u=a("div"),b=a("h2"),L=c("Static site front-end for Google Sheets"),D=g(),k=a("section"),s=a("div"),A=a("h5"),N=c("Overview"),O=g(),p=a("article"),d=a("div"),y=a("h3"),z=c("Motivation"),C=g(),G=a("p"),V=c(`Automated workflows using custom scripted Google Sheets are extremely effective, but can be overwhelming. A
            well designed front-end view gives much more control over how the data is displayed. This makes the
            aggregate data much more presentable and digestible while still using the Google Sheets as the data source.
            High level decisions like approvals can be made in the front-end.`),W=g(),w=a("article"),h=a("div"),x=a("h3"),J=c("Tech Stack"),M=g(),T=a("p"),P=c(`Google Sheets was already established as the primary workflow. We chose React for it's ability to render and
            sort long lists efficiently. The site also needed to run in an Amazon S3 environment, so Next.js was good
            fit to generate static pages. The pages would make requests for Google Sheet data using the url query
            string. An AWS Lambda function would format the Google Sheet data and send a JSON response to the page.
            Actions like changes in approval would trigger another Lambda function that would write data back to the
            connected Google Sheet.`),j=g(),I=a("h5"),B=c("Screen Recording"),F=g(),S=a("article"),i=a("video"),this.h()},l(H){n=o(H,"MAIN",{});var _=r(n);E=o(_,"HEADER",{});var U=r(E);u=o(U,"DIV",{class:!0});var X=r(u);b=o(X,"H2",{});var Y=r(b);L=f(Y,"Static site front-end for Google Sheets"),Y.forEach(t),X.forEach(t),U.forEach(t),D=v(_),k=o(_,"SECTION",{});var Z=r(k);s=o(Z,"DIV",{});var l=r(s);A=o(l,"H5",{});var $=r(A);N=f($,"Overview"),$.forEach(t),O=v(l),p=o(l,"ARTICLE",{class:!0});var ee=r(p);d=o(ee,"DIV",{});var R=r(d);y=o(R,"H3",{});var te=r(y);z=f(te,"Motivation"),te.forEach(t),C=v(R),G=o(R,"P",{});var ae=r(G);V=f(ae,`Automated workflows using custom scripted Google Sheets are extremely effective, but can be overwhelming. A
            well designed front-end view gives much more control over how the data is displayed. This makes the
            aggregate data much more presentable and digestible while still using the Google Sheets as the data source.
            High level decisions like approvals can be made in the front-end.`),ae.forEach(t),R.forEach(t),ee.forEach(t),W=v(l),w=o(l,"ARTICLE",{class:!0});var oe=r(w);h=o(oe,"DIV",{});var q=r(h);x=o(q,"H3",{});var re=r(x);J=f(re,"Tech Stack"),re.forEach(t),M=v(q),T=o(q,"P",{});var se=r(T);P=f(se,`Google Sheets was already established as the primary workflow. We chose React for it's ability to render and
            sort long lists efficiently. The site also needed to run in an Amazon S3 environment, so Next.js was good
            fit to generate static pages. The pages would make requests for Google Sheet data using the url query
            string. An AWS Lambda function would format the Google Sheet data and send a JSON response to the page.
            Actions like changes in approval would trigger another Lambda function that would write data back to the
            connected Google Sheet.`),se.forEach(t),q.forEach(t),oe.forEach(t),j=v(l),I=o(l,"H5",{});var ne=r(I);B=f(ne,"Screen Recording"),ne.forEach(t),F=v(l),S=o(l,"ARTICLE",{class:!0});var ie=r(S);i=o(ie,"VIDEO",{preload:!0,src:!0,poster:!0}),r(i).forEach(t),ie.forEach(t),l.forEach(t),Z.forEach(t),_.forEach(t),this.h()},h(){m(u,"class","right-margin-lrg"),m(p,"class","flex-horiz"),m(w,"class","flex-horiz"),m(i,"preload","auto"),i.muted=!0,i.controls=!0,fe(i.src,Q=le+"/video/instagram/ig-demo.mp4")||m(i,"src",Q),m(i,"poster",le+"/images/instagram/poster.png"),m(S,"class","flex-horiz")},m(H,_){ve(H,n,_),e(n,E),e(E,u),e(u,b),e(b,L),e(n,D),e(n,k),e(k,s),e(s,A),e(A,N),e(s,O),e(s,p),e(p,d),e(d,y),e(y,z),e(d,C),e(d,G),e(G,V),e(s,W),e(s,w),e(w,h),e(h,x),e(x,J),e(h,M),e(h,T),e(T,P),e(s,j),e(s,I),e(I,B),e(s,F),e(s,S),e(S,i)},p:K,i:K,o:K,d(H){H&&t(n)}}}class we extends he{constructor(n){super(),ce(this,n,null,me,ge,{})}}export{we as component};
